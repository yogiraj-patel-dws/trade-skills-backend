// This is your Prisma schema file,
// learn more about it in the docs: https://pris.ly/d/prisma-schema

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

// User Management
model User {
  id            String   @id @default(uuid())
  email         String   @unique
  password      String
  googleId      String?   @unique
  role          UserRole @default(USER)
  isActive      Boolean  @default(true)
  isVerified    Boolean  @default(false)
  verificationToken String?
  resetToken    String?
  resetTokenExpiry BigInt? @db.BigInt
  createdAt     BigInt @default(dbgenerated("extract(epoch from now()) * 1000")) @db.BigInt
  updatedAt     BigInt @db.BigInt

  // Relations
  profile       UserProfile?
  userSkills    UserSkill[]
  wallet        Wallet?
  hostedSessions Session[] @relation("SessionHost")
  participantSessions SessionParticipant[]
  sentReviews   Review[] @relation("ReviewSender")
  receivedReviews Review[] @relation("ReviewReceiver")
  reports       Report[]
  notifications Notification[]
  adminActions  AdminAction[]

  @@map("users")
}

model UserProfile {
  id           String   @id @default(uuid())
  userId       String   @unique
  firstName    String
  lastName     String
  bio          String?
  profilePicture String?
  phoneNumber  String?
  timezone     String?
  availability Json?    // Store availability slots as JSON
  rating       Float    @default(0.0)
  totalReviews Int      @default(0)
  createdAt    BigInt @default(dbgenerated("extract(epoch from now()) * 1000")) @db.BigInt
  updatedAt    BigInt @db.BigInt

  // Relations
  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@map("user_profiles")
}

// Skills Management
model Skill {
  id          String @id @default(uuid())
  name        String @unique
  description String?
  category    String
  isActive    Boolean @default(true)
  createdAt   BigInt @default(dbgenerated("extract(epoch from now()) * 1000")) @db.BigInt

  // Relations
  userSkills UserSkill[]

  @@map("skills")
}

model UserSkill {
  id           String      @id @default(uuid())
  userId       String
  skillId      String
  level        SkillLevel
  yearsOfExperience Int?
  canTeach     Boolean     @default(false)
  wantsToLearn Boolean     @default(false)
  
  // Teaching-specific fields
  skillTitle   String?     // Custom title for teaching (e.g. "Master React in 30 Days")
  bannerImage  String?     // Banner image URL
  demoVideo    String?     // Demo video URL
  teachingLanguage String? // e.g. "English, Spanish"
  prerequisites String?    // Prerequisites & requirements text
  subcategory  String?     // Subcategory within the skill category
  
  createdAt    BigInt @default(dbgenerated("extract(epoch from now()) * 1000")) @db.BigInt
  updatedAt    BigInt @default(dbgenerated("extract(epoch from now()) * 1000")) @db.BigInt

  // Relations
  user  User  @relation(fields: [userId], references: [id], onDelete: Cascade)
  skill Skill @relation(fields: [skillId], references: [id], onDelete: Cascade)

  @@unique([userId, skillId])
  @@map("user_skills")
}

// Session Management
model Session {
  id          String        @id @default(uuid())
  title       String
  description String?
  hostId      String
  skillId     String?
  sessionType SessionType
  status      SessionStatus @default(PENDING)
  maxParticipants Int?
  creditCost  Int
  scheduledAt BigInt @db.BigInt
  duration    Int           // Duration in minutes
  meetingLink String?
  meetingId   String?
  actualStartTime BigInt? @db.BigInt
  actualEndTime BigInt? @db.BigInt
  createdAt   BigInt @default(dbgenerated("extract(epoch from now()) * 1000")) @db.BigInt
  updatedAt   BigInt @db.BigInt

  // Relations
  host         User @relation("SessionHost", fields: [hostId], references: [id])
  participants SessionParticipant[]
  transactions Transaction[]

  @@map("sessions")
}

model SessionParticipant {
  id        String              @id @default(uuid())
  sessionId String
  userId    String
  status    ParticipantStatus   @default(PENDING)
  joinedAt  BigInt? @db.BigInt
  leftAt    BigInt? @db.BigInt
  createdAt BigInt @default(dbgenerated("extract(epoch from now()) * 1000")) @db.BigInt

  // Relations
  session Session @relation(fields: [sessionId], references: [id], onDelete: Cascade)
  user    User    @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([sessionId, userId])
  @@map("session_participants")
}

// Credit & Wallet System
model Wallet {
  id              String @id @default(uuid())
  userId          String @unique
  availableCredits Int   @default(0)
  lockedCredits   Int    @default(0)
  totalEarned     Int    @default(0)
  totalSpent      Int    @default(0)
  createdAt       BigInt @default(dbgenerated("extract(epoch from now()) * 1000")) @db.BigInt
  updatedAt       BigInt @db.BigInt

  // Relations
  user         User          @relation(fields: [userId], references: [id], onDelete: Cascade)
  transactions Transaction[]
  creditLocks  CreditLock[]

  @@map("wallets")
}

model Transaction {
  id          String            @id @default(uuid())
  walletId    String
  sessionId   String?
  paymentId   String?
  type        TransactionType
  amount      Int
  description String?
  status      TransactionStatus @default(PENDING)
  createdAt   BigInt @default(dbgenerated("extract(epoch from now()) * 1000")) @db.BigInt
  updatedAt   BigInt @db.BigInt

  // Relations
  wallet  Wallet   @relation(fields: [walletId], references: [id], onDelete: Cascade)
  session Session? @relation(fields: [sessionId], references: [id])
  payment Payment? @relation(fields: [paymentId], references: [id])

  @@map("transactions")
}

model CreditLock {
  id        String    @id @default(uuid())
  walletId  String
  sessionId String
  amount    Int
  reason    String
  lockedAt  BigInt @default(dbgenerated("extract(epoch from now()) * 1000")) @db.BigInt
  releasedAt BigInt? @db.BigInt
  isReleased Boolean  @default(false)

  // Relations
  wallet Wallet @relation(fields: [walletId], references: [id], onDelete: Cascade)

  @@map("credit_locks")
}

// Payment System
model Payment {
  id              String        @id @default(uuid())
  userId          String
  packageId       String
  amount          Float
  currency        String        @default("INR")
  gateway         PaymentGateway
  gatewayOrderId  String
  gatewayPaymentId String?
  status          PaymentStatus @default(PENDING)
  creditsAwarded  Int?
  failureReason   String?
  createdAt       BigInt @default(dbgenerated("extract(epoch from now()) * 1000")) @db.BigInt
  updatedAt       BigInt @db.BigInt

  // Relations
  package      PaymentPackage @relation(fields: [packageId], references: [id])
  transactions Transaction[]

  @@map("payments")
}

model PaymentPackage {
  id          String  @id @default(uuid())
  name        String
  description String?
  credits     Int
  price       Float
  currency    String  @default("INR")
  isActive    Boolean @default(true)
  createdAt   BigInt @default(dbgenerated("extract(epoch from now()) * 1000")) @db.BigInt

  // Relations
  payments Payment[]

  @@map("payment_packages")
}

// Reviews & Ratings
model Review {
  id         String @id @default(uuid())
  senderId   String
  receiverId String
  sessionId  String?
  rating     Int    // 1-5 scale
  comment    String?
  createdAt  BigInt @default(dbgenerated("extract(epoch from now()) * 1000")) @db.BigInt

  // Relations
  sender   User @relation("ReviewSender", fields: [senderId], references: [id], onDelete: Cascade)
  receiver User @relation("ReviewReceiver", fields: [receiverId], references: [id], onDelete: Cascade)

  @@map("reviews")
}

// Reports & Moderation
model Report {
  id          String      @id @default(uuid())
  reporterId  String
  reportedUserId String?
  sessionId   String?
  type        ReportType
  reason      String
  description String?
  status      ReportStatus @default(PENDING)
  resolvedBy  String?
  resolvedAt  BigInt? @db.BigInt
  createdAt   BigInt @default(dbgenerated("extract(epoch from now()) * 1000")) @db.BigInt

  // Relations
  reporter User @relation(fields: [reporterId], references: [id], onDelete: Cascade)

  @@map("reports")
}

// Notifications
model Notification {
  id        String           @id @default(uuid())
  userId    String
  type      NotificationType
  title     String
  message   String
  data      Json?            // Additional data as JSON
  isRead    Boolean          @default(false)
  createdAt BigInt @default(dbgenerated("extract(epoch from now()) * 1000")) @db.BigInt

  // Relations
  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@map("notifications")
}

// Admin & Audit
model AdminAction {
  id          String     @id @default(uuid())
  adminId     String
  targetUserId String?
  action      String
  description String?
  metadata    Json?
  createdAt   BigInt @default(dbgenerated("extract(epoch from now()) * 1000")) @db.BigInt

  // Relations
  admin User @relation(fields: [adminId], references: [id])

  @@map("admin_actions")
}

// Enums
enum UserRole {
  USER
  ADMIN
  SUPER_ADMIN
}

enum SkillLevel {
  BEGINNER
  INTERMEDIATE
  ADVANCED
  EXPERT
}

enum SessionType {
  ONE_ON_ONE
  ONE_TO_MANY
}

enum SessionStatus {
  PENDING
  CONFIRMED
  IN_PROGRESS
  COMPLETED
  CANCELLED
  NO_SHOW
}

enum ParticipantStatus {
  PENDING
  CONFIRMED
  JOINED
  LEFT
  CANCELLED
}

enum TransactionType {
  CREDIT_PURCHASE
  SESSION_PAYMENT
  SESSION_EARNING
  REFUND
  ADMIN_ADJUSTMENT
}

enum TransactionStatus {
  PENDING
  COMPLETED
  FAILED
  CANCELLED
}

enum PaymentGateway {
  RAZORPAY
  STRIPE
  PAYPAL
}

enum PaymentStatus {
  PENDING
  COMPLETED
  FAILED
  CANCELLED
  REFUNDED
}

enum ReportType {
  INAPPROPRIATE_BEHAVIOR
  SPAM
  FRAUD
  TECHNICAL_ISSUE
  OTHER
}

enum ReportStatus {
  PENDING
  INVESTIGATING
  RESOLVED
  DISMISSED
}

enum NotificationType {
  SESSION_REQUEST
  SESSION_CONFIRMED
  SESSION_CANCELLED
  SESSION_REMINDER
  PAYMENT_SUCCESS
  PAYMENT_FAILED
  CREDIT_RECEIVED
  REVIEW_RECEIVED
  SYSTEM_ANNOUNCEMENT
}